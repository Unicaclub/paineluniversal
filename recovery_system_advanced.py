#!/usr/bin/env python3
"""
üõ°Ô∏è SISTEMA DE RECOVERY AVAN√áADO PARA PAINELUNIVERSAL
Implementa m√∫ltiplas estrat√©gias de conex√£o e recupera√ß√£o autom√°tica
Preserva funcionalidades existentes com zero downtime
"""

import os
import sys
import time
import asyncio
import logging
import asyncpg
import psycopg2
from datetime import datetime
from typing import List, Dict, Any, Optional, Callable
from dataclasses import dataclass
from pathlib import Path

# Adicionar backend ao path
sys.path.insert(0, str(Path(__file__).parent / "backend"))

try:
    from app.migrations.auto_migrate import AutoMigration, DeployMonitoring
    EXISTING_SYSTEM_AVAILABLE = True
except ImportError:
    EXISTING_SYSTEM_AVAILABLE = False

# Configurar logging estruturado
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('migration_recovery.log')
    ]
)

logger = logging.getLogger("recovery_system")

@dataclass
class ConnectionAttempt:
    """Representa uma tentativa de conex√£o"""
    strategy: str
    url: str
    success: bool
    duration: float
    error: Optional[str] = None

@dataclass
class MigrationResult:
    """Resultado de uma migra√ß√£o"""
    strategy: str
    success: bool
    duration: float
    operations_completed: List[str]
    errors: List[str]

class ConnectionStrategy:
    """Estrat√©gias de conex√£o com PostgreSQL"""
    
    @staticmethod
    def get_railway_urls() -> List[str]:
        """Obt√©m URLs do Railway de diferentes fontes"""
        urls = []
        
        # URL principal do ambiente
        main_url = os.getenv("DATABASE_URL")
        if main_url:
            urls.append(main_url)
        
        # URLs alternativas conhecidas (mascaradas para seguran√ßa)
        alternative_urls = [
            os.getenv("POSTGRES_URL"),
            os.getenv("DATABASE_PRIVATE_URL"),
            os.getenv("DATABASE_PUBLIC_URL"),
        ]
        
        # Filtrar URLs v√°lidas
        urls.extend([url for url in alternative_urls if url])
        
        # Normalizar URLs postgres:// -> postgresql://
        normalized_urls = []
        for url in urls:
            if url.startswith("postgres://"):
                normalized_urls.append(url.replace("postgres://", "postgresql://", 1))
            else:
                normalized_urls.append(url)
        
        return list(set(normalized_urls))  # Remove duplicatas
    
    @staticmethod
    async def try_asyncpg_connection(url: str, timeout: int = 30) -> ConnectionAttempt:
        """Tenta conex√£o com asyncpg"""
        start_time = time.time()
        
        try:
            conn = await asyncio.wait_for(
                asyncpg.connect(url),
                timeout=timeout
            )
            await conn.close()
            
            duration = time.time() - start_time
            logger.info(f"‚úÖ asyncpg conex√£o bem-sucedida em {duration:.2f}s")
            
            return ConnectionAttempt(
                strategy="asyncpg",
                url=url[:50] + "...",  # Mascarar URL
                success=True,
                duration=duration
            )
            
        except Exception as e:
            duration = time.time() - start_time
            logger.warning(f"‚ùå asyncpg falhou em {duration:.2f}s: {e}")
            
            return ConnectionAttempt(
                strategy="asyncpg",
                url=url[:50] + "...",
                success=False,
                duration=duration,
                error=str(e)
            )
    
    @staticmethod
    def try_psycopg2_connection(url: str, timeout: int = 30) -> ConnectionAttempt:
        """Tenta conex√£o com psycopg2"""
        start_time = time.time()
        
        try:
            conn = psycopg2.connect(url, connect_timeout=timeout)
            conn.close()
            
            duration = time.time() - start_time
            logger.info(f"‚úÖ psycopg2 conex√£o bem-sucedida em {duration:.2f}s")
            
            return ConnectionAttempt(
                strategy="psycopg2",
                url=url[:50] + "...",
                success=True,
                duration=duration
            )
            
        except Exception as e:
            duration = time.time() - start_time
            logger.warning(f"‚ùå psycopg2 falhou em {duration:.2f}s: {e}")
            
            return ConnectionAttempt(
                strategy="psycopg2",
                url=url[:50] + "...",
                success=False,
                duration=duration,
                error=str(e)
            )

class RecoverySystem:
    """Sistema de recupera√ß√£o autom√°tica com m√∫ltiplas estrat√©gias"""
    
    def __init__(self):
        self.logger = logging.getLogger("recovery")
        self.connection_attempts: List[ConnectionAttempt] = []
        self.migration_results: List[MigrationResult] = []
        
    async def test_all_connections(self) -> Optional[str]:
        """Testa todas as estrat√©gias de conex√£o dispon√≠veis"""
        self.logger.info("üîç Testando conectividade PostgreSQL...")
        
        urls = ConnectionStrategy.get_railway_urls()
        if not urls:
            self.logger.error("‚ùå Nenhuma URL de banco encontrada")
            return None
        
        self.logger.info(f"üìã Testando {len(urls)} URL(s) de conex√£o")
        
        for url in urls:
            # Testar asyncpg
            attempt = await ConnectionStrategy.try_asyncpg_connection(url)
            self.connection_attempts.append(attempt)
            
            if attempt.success:
                self.logger.info(f"‚úÖ Conex√£o bem-sucedida: {attempt.strategy}")
                return url
            
            # Testar psycopg2
            attempt = ConnectionStrategy.try_psycopg2_connection(url)
            self.connection_attempts.append(attempt)
            
            if attempt.success:
                self.logger.info(f"‚úÖ Conex√£o bem-sucedida: {attempt.strategy}")
                return url
            
            # Delay entre tentativas
            await asyncio.sleep(2)
        
        self.logger.error("‚ùå Todas as tentativas de conex√£o falharam")
        return None
    
    def use_existing_auto_migration(self) -> bool:
        """Usa o sistema de auto-migra√ß√£o existente"""
        if not EXISTING_SYSTEM_AVAILABLE:
            self.logger.warning("‚ö†Ô∏è Sistema de auto-migra√ß√£o n√£o dispon√≠vel")
            return False
        
        try:
            self.logger.info("üîß Usando sistema de auto-migra√ß√£o existente...")
            
            # Usar o sistema existente que j√° √© robusto
            from app.migrations.auto_migrate import run_auto_migration
            
            success = run_auto_migration()
            
            if success:
                self.logger.info("‚úÖ Migra√ß√£o autom√°tica bem-sucedida")
                return True
            else:
                self.logger.error("‚ùå Migra√ß√£o autom√°tica falhou")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erro no sistema de auto-migra√ß√£o: {e}")
            return False
    
    def generate_manual_sql_script(self) -> str:
        """Gera script SQL para execu√ß√£o manual no Railway Console"""
        sql_script = """
-- üõ†Ô∏è SCRIPT DE RECOVERY MANUAL - RAILWAY CONSOLE
-- Execute este script diretamente no Railway PostgreSQL Console

BEGIN;

-- 1. CORRE√á√ÉO ENUM TIPOUSUARIO
DO $$
BEGIN
    -- Criar enum se n√£o existir
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'tipousuario') THEN
        CREATE TYPE tipousuario AS ENUM ('admin', 'promoter', 'cliente');
        RAISE NOTICE 'Enum tipousuario criado';
    END IF;
    
    -- Adicionar valores lowercase se necess√°rio
    BEGIN
        ALTER TYPE tipousuario ADD VALUE IF NOT EXISTS 'admin';
        RAISE NOTICE 'Valor admin adicionado';
    EXCEPTION WHEN duplicate_object THEN
        RAISE NOTICE 'Valor admin j√° existe';
    END;
    
    BEGIN
        ALTER TYPE tipousuario ADD VALUE IF NOT EXISTS 'promoter';
        RAISE NOTICE 'Valor promoter adicionado';
    EXCEPTION WHEN duplicate_object THEN
        RAISE NOTICE 'Valor promoter j√° existe';
    END;
    
    BEGIN
        ALTER TYPE tipousuario ADD VALUE IF NOT EXISTS 'cliente';
        RAISE NOTICE 'Valor cliente adicionado';
    EXCEPTION WHEN duplicate_object THEN
        RAISE NOTICE 'Valor cliente j√° existe';
    END;
END $$;

-- 2. CORRIGIR USU√ÅRIOS COM CASE MISMATCH
UPDATE usuarios SET tipo = 'admin' WHERE tipo = 'ADMIN';
UPDATE usuarios SET tipo = 'promoter' WHERE tipo = 'PROMOTER';
UPDATE usuarios SET tipo = 'cliente' WHERE tipo = 'CLIENTE';

-- 3. MIGRA√á√ÉO TABELA PRODUTOS (SE NECESS√ÅRIO)
DO $$
BEGIN
    -- Verificar se evento_id existe
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'produtos' AND column_name = 'evento_id'
    ) THEN
        RAISE NOTICE 'Coluna evento_id encontrada, removendo...';
        
        -- Backup
        EXECUTE 'CREATE TABLE produtos_backup_' || TO_CHAR(NOW(), 'YYYYMMDD_HH24MISS') || ' AS SELECT * FROM produtos';
        RAISE NOTICE 'Backup criado';
        
        -- Remover coluna
        ALTER TABLE produtos DROP COLUMN evento_id;
        RAISE NOTICE 'Coluna evento_id removida';
        
        -- Recriar √≠ndices
        CREATE INDEX IF NOT EXISTS idx_produtos_categoria ON produtos(categoria);
        CREATE INDEX IF NOT EXISTS idx_produtos_tipo ON produtos(tipo);
        CREATE INDEX IF NOT EXISTS idx_produtos_status ON produtos(status);
        
        RAISE NOTICE '√çndices recriados';
    ELSE
        RAISE NOTICE 'Coluna evento_id n√£o encontrada, migra√ß√£o n√£o necess√°ria';
    END IF;
END $$;

-- 4. VALIDA√á√ÉO
SELECT 'ENUM_VALUES' as tipo, enumlabel as valor 
FROM pg_enum 
WHERE enumtypid = (SELECT oid FROM pg_type WHERE typname = 'tipousuario')
ORDER BY enumsortorder;

SELECT 'PRODUTOS_COUNT' as tipo, COUNT(*) as valor FROM produtos;

SELECT 'USUARIOS_TIPOS' as tipo, tipo, COUNT(*) as valor 
FROM usuarios 
GROUP BY tipo;

COMMIT;

-- ‚úÖ SCRIPT CONCLU√çDO
SELECT '‚úÖ RECOVERY MANUAL CONCLU√çDO COM SUCESSO' as status;
"""
        return sql_script
    
    async def run_comprehensive_recovery(self) -> bool:
        """Executa recovery abrangente com m√∫ltiplas estrat√©gias"""
        self.logger.info("üöÄ Iniciando recovery abrangente do sistema...")
        
        start_time = time.time()
        
        # Estrat√©gia 1: Testar conectividade
        working_url = await self.test_all_connections()
        
        if working_url:
            self.logger.info("‚úÖ Conectividade PostgreSQL funcionando")
            
            # Estrat√©gia 2: Usar sistema existente (preferencial)
            if self.use_existing_auto_migration():
                duration = time.time() - start_time
                self.logger.info(f"üéâ Recovery bem-sucedido em {duration:.2f}s")
                return True
        
        # Estrat√©gia 3: Fallback para script manual
        self.logger.warning("‚ö†Ô∏è Conectividade falhou, gerando script manual...")
        
        script = self.generate_manual_sql_script()
        script_path = "railway_manual_recovery.sql"
        
        with open(script_path, 'w', encoding='utf-8') as f:
            f.write(script)
        
        self.logger.info(f"üìù Script manual gerado: {script_path}")
        self.logger.info("üîß Execute o script no Railway Console para recovery manual")
        
        return False
    
    def generate_recovery_report(self) -> str:
        """Gera relat√≥rio detalhado do recovery"""
        report = f"""
# üìä RELAT√ìRIO DE RECOVERY - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## üîç TENTATIVAS DE CONEX√ÉO
"""
        
        for attempt in self.connection_attempts:
            status = "‚úÖ" if attempt.success else "‚ùå"
            report += f"- {status} {attempt.strategy}: {attempt.duration:.2f}s"
            if attempt.error:
                report += f" (Erro: {attempt.error[:100]}...)"
            report += "\n"
        
        report += f"""
## üìà RESULTADOS DE MIGRA√á√ÉO
"""
        
        for result in self.migration_results:
            status = "‚úÖ" if result.success else "‚ùå"
            report += f"- {status} {result.strategy}: {result.duration:.2f}s\n"
            if result.operations_completed:
                report += f"  Opera√ß√µes: {', '.join(result.operations_completed)}\n"
            if result.errors:
                report += f"  Erros: {', '.join(result.errors)}\n"
        
        return report

def main():
    """Executa recovery do sistema"""
    print("üõ°Ô∏è SISTEMA DE RECOVERY PAINELUNIVERSAL")
    print("=" * 50)
    
    recovery = RecoverySystem()
    
    try:
        # Executar recovery
        success = asyncio.run(recovery.run_comprehensive_recovery())
        
        # Gerar relat√≥rio
        report = recovery.generate_recovery_report()
        
        with open("recovery_report.md", 'w', encoding='utf-8') as f:
            f.write(report)
        
        if success:
            print("‚úÖ RECOVERY CONCLU√çDO COM SUCESSO!")
            print("üìä Relat√≥rio: recovery_report.md")
            return 0
        else:
            print("‚ö†Ô∏è RECOVERY PARCIAL - Script manual gerado")
            print("üìù Execute railway_manual_recovery.sql no Railway Console")
            print("üìä Relat√≥rio: recovery_report.md")
            return 1
            
    except Exception as e:
        logger.error(f"‚ùå Erro fatal no recovery: {e}")
        print(f"‚ùå ERRO FATAL: {e}")
        return 1

if __name__ == "__main__":
    exit(main())
